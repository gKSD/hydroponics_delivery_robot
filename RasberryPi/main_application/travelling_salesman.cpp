/*задача коммивояжёра
Коммивояжёр (бродячий торговец) должен выйти из первого города, посетить по разу
в неизвестном порядке города и вернуться в первый город.
Расстояние между городами известны. В каком порядке следует обходить города,
чтобы замкнутый путь (тур) коммивояжёра был кротчайшим.
Иными словами, коммивояжёр должен обойти все города по кротчайшему пути и
при этом посещая каждый город только один раз.
Расстояния берутся из файла. В файле матрица с произвольными правильными
значениями (т.е. значение не отрицательны и такие, что проход коммивояжёром
всех городов возможен).
Программа ищет путь с помощью метода ветвей и границ.
*/
//#include "stdafx.h"
#include <iostream>
#include "travelling_salesman.hpp"





              //максимум городов


Travelling_salesman::Travelling_salesman(int n, int **routes) {
	_n = n;
	_minm = new int[n];
	_m = new int[n];
	a = routes;
}

int* Travelling_salesman::Output()                    //вывод данных
{
	//ofstream fout("output.txt");   //открыли файл
	int *routes = new int[_n];
	if (_found)                        //если найден маршрут...
	{
		//std::cout << "Lenght of min path = " << _min << std::endl;
		std::cout << "Path : ";
		int c = 1; 
		int counter = 0;//номер в порядке обхода городов
		for (int i = 1; i <= _n; i++)      //пробегаем по всем городам
		{
			int j = 1;
			while ((j <= _n) &&                //ищем следующий город в порядке обхода    
				(_minm[j] != c)) j++; 
			std::cout << j << "->";
			routes[counter] = j;
			counter++;
			c++;
		}
		routes[counter] = _minm[1];
		std::cout << _minm[1] << std::endl;    //обход завершается первым городом
	}
	//else std::cout << "Path not found!";
	return routes;
}
void Travelling_salesman::Search(int x)                //поиск следующего города в порядке 
//обхода после города с номером Х
{
	if ((_count == _n) &&                //если просмотрели все города
		(a[x][1] != 0) &&                //из последнего города есть путь в первый город
		(_s + a[x][1]<_min))            //новая сумма расстояний меньше минимальной суммы
	{
		_found = 1;                    //маршрут найден
		_min = _s + a[x][1];                //изменяем: новая минимальная сумма расстояний
		for (int i = 1; i <= _n; i++)
			_minm[i] = _m[i];//изменяем: новый минимальный путь
	}
	else
	{
		for (int i = 1; i <= _n; i++)     //из текущего города просматриваем все города
		if ((i != x) &&                //новый город не совпадает с текущим    
			(a[x][i] != 0) &&            //есть прямой путь из x в i
			(_m[i] == 0) &&            //новый город еще не простотрен
			(_s + a[x][i]<_min))    //текущая сумма не превышает минимальной
		{
			_s += a[x][i];                //наращиваем сумму
			_count++;                //количество просмотренных городав
			_m[i] = _count;                //отмечаем у нового города новый номер в порядке обхода
			Search(i);                //поиск нового города начиная с города i
			_m[i] = 0;                    //возвращаем все назад
			_count--;                //-"-
			_s -= a[x][i];                //-"-
		}
	}
}
void Travelling_salesman::Run()
{                                //инициализация                                
	_s = 0;
	_found = 0;
	_min = 32767;
	for (int i = 1; i <= _n; i++) _m[i] = 0;
	_count = 1;
	_m[1] = _count;                        //считаем что поиск начинается с первого города
	Search(1);                        //считаем что поиск начинается с первого города
}
